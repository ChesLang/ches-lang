# 2-3. 変数の可変性

変数の基本的な用途は一般的なプログラミング言語と同様ですが、可変性や所有権などといった独特の概念が取り入れられています。(Rust 習得者にはお馴染みでしょう。)

所有権に関する知識は今後解説するとして、今回は可変性を学習しましょう。

変数内部の状態を変更できる変数を可変変数 (*mutable variable*)、変更できない変数を不変変数 (*immutable variable*) と呼び、このような特性を総称して可変性といいます。

一般的な定数と可変変数の違いとして、定数は再代入が発生しないことを保証しますが、可変変数は変数内部の状態が変化しないことを保証するという点が挙げられます。

そのため可変変数は再代入できないだけでなくフィールド (メンバ変数) 値さえ変更できないという制約を持ちます。

一般的なプログラミング言語では何もしなくとも自由に変数内部の状態を変更することができますが、安全上の理由で Ches で定義された変数はデフォルトで不変となります。

以下では可変変数を定義する方法とともに変数構文を紹介します。

`2-3.1`

```ruby
# 不変変数を定義
let num
# 初期化
let num = 0

# [!エラー] 不変なので内部状態は変更できない
num += 1
```

`2-3.2`

```ruby
# 可変変数を定義 (mut キーワードが必要)
let mut num
# 初期化
let mut num = 0

# [正常] 可変なので内部状態を変更できる
num += 1
```

このように自由に変数値を扱うには `mut` キーワードで変数を可変にしなければならないため、少々面倒な仕組みに思えるかもしれませんがこれには安全上のメリットがあります。

それは変数値の状態が変更されるべきかどうかを明示することで、プログラマが間違えて変更されるべきでない変数を変更してもコンパイラがそれを検知し、バグを未然に防ぐことができることです。

小難しい説明が続きましたが、最後に変数を使ったプログラムを動かしてみましょう。

`2-3.3`

```ruby
fn main()
    let input = readln()
    let reverse_input = input.reverse()
    println("`${input}` をひっくり返すと `${reverse_input}` になります")
end
```

文字列リテラル内の `${}` は今後解説しますが文字列フォーマットの構文です。

---

Copyright © 2019- Ches All rights reserved.
