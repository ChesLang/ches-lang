# モジュール

木構造形式で機能別にプログラムを分割することにより効率的なコーディングをサポートする仕組みである。

モジュールによるプログラム分割はコーディングに以下のような恩恵をもたらす。

- プログラム構造の見通し向上
- モジュール名を利用した重複アイテム名の区別

モジュール構造のルートとしてメインモジュールが存在し、ノードにあたる子モジュールの中にはさらに子モジュールを定義することができる。

モジュール内の [アイテム](#アイテム) はリーフにあたるため、アイテム内にモジュールを置くことはできない。

## アイテム

以下に示すモジュール内に配置可能な要素を指す。

- use 宣言
- モジュール
- 構造体
- 列挙体
- 特性体
- 関数
- 型エイリアス

## ファイルパス

モジュールとソースファイルは対になっている。

モジュール名はソースファイル名から判断されるため、モジュールを定義するにはソースファイル `モジュール名.ches` を作成してファイル内にモジュール内要素を記述する。

プログラムをコンパイルする際は必ず `main.ches` としてメインモジュールを定義する必要がある。

親モジュール内に子モジュールを定義する場合は `親モジュール名/子モジュール名.ches` というように親モジュールの名前を付けたディレクトリの中にソースファイルを置く。

例えば `#モジュール構造#` のようにモジュールを配置する場合はファイル構成を `#ファイル構成#` にしなければならない。

```
#モジュール構造#
main
  |_ sub1
    |_ sub1_2
  |_ sub2
```

```
#ファイル構成#
main.ches
sub1.ches
sub1/sub1_2.ches
sub2.ches
```

## use 宣言

アイテムの利用を宣言する (「use 宣言する」もしくは「use する」) ことでそのアイテムの [スコープパス](../../../../../../inprep/index.md) を相対的に表すことができる。

あらゆるスコープにおいて use を宣言することができ、相対的なスコープパスの記述は use 宣言がなされたスコープでのみ可能である。

例えばあるブロックの中でアイテム `a` を use した場合、そのスコープに限り `a` のスコープパスは `a` となる。

一方でモジュール `b` を use した場合、その中に定義されたアイテム `c` を利用するにはスコープパスを `b::c` とすればよい。

```
# main モジュールを use する
use main

# 複数のアイテムを一括で use する
use {
    main::{
        Item1
        Item2
    }
    other_project
}

# main モジュール内のアイテム Item のみを use する
use main::Item

# main モジュール内の全アイテムを一括で use する
use main::*
```

## 仕様変更

### 将来的な変更

将来的にモジュールをブロックとしてソースファイル内に定義できるようモジュール定義構文を追加する可能性がある。

---

Copyright © 2019- Ches All rights reserved.
