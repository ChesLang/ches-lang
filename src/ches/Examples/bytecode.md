# バイトコード仕様書

## 例

```js
Hello

const(str[] args)
    greet()

greet(str msg)
    greet("Hello, " + msg + "!")

println(str msg)
    print(msg + "\n")
```

```
ORINCHAN

LABEL       1EF211C31E849269    Examples.Hello.const

LSPUSH      B8FB5A506D94846C
CALL
LSPUSH      NULL
RETURN

LABEL       B8FB5A506D94846C    Examples.Hello.greet

LSPUSH      "Hello, "
LSPUSH      $0
JOIN
LSPUSH      "!"
JOIN
CALL        0577DE596A4147F5
LSPUSH      NULL
RETURN

LABEL       0577DE596A4147F5    global.println

LSPUSH      $0
LSPUSH      "\n"
JOIN
LSPUSH      5362B37V18DEE91F
CALL
LSPUSH      NULL
RETURN
```

## 例

### if文 (比較: <=)

```
LSPUSH      123     ; 比較元
LSPUSH      321     ; 比較先

COMP                ; 一致の比較
LSPUSH      6       ; 不一致時のジャンプ先
IFJUMP              ; ジャンプ

GREATER             ; 大小の比較
LSPUSH      3       ; 小さい時のジャンプ先
IFJUMP              ; ジャンプ

JUMP        1EF211C31E849269    ; 任意の処理
```

### for文

ループ回数の変更がない場合

```
; インデックス処理

LSPUSH      32      123     ; ループ回数
LSPUSH      32      0       ; インデクサ

; 条件式の処理

COMP                        ; インデックスの一致の比較
LSPUSH      16      9       ; 不一致時のジャンプ先
IFJUMP              ; ジャンプ

GREATER             ; インデックスの大小の比較
LSPUSH      6       ; 小さい時のジャンプ先
IFJUMP              ; ジャンプ

; 任意の処理

JUMP        1EF211C31E849269    ; 任意の処理

; インデックス処理

LSPUSH      1       ; 加算する数
ADD                 ; インデックス加算
IFJUMP      -9      ; 条件式を処理
```

ループ回数の変更がある場合

```
; インデックス処理

LSPUSH      123     ; ループ回数
LLPUSH      32      123     ; ループ回数
LLPUSH      $0
LSPUSH      0       ; インデクサ

; 条件式の処理

COMP                ; インデックスの一致の比較
LSPUSH      9       ; 不一致時のジャンプ先
IFJUMP              ; ジャンプ

GREATER             ; インデックスの大小の比較
LSPUSH      6       ; 小さい時のジャンプ先
IFJUMP              ; ジャンプ

; 任意の処理

JUMP        1EF211C31E849269    ; 任意の処理

; インデックス処理

LSPUSH      1       ; 加算する数
ADD                 ; インデックス加算
IFJUMP      -9      ; 条件式を処理
```

## 命令一覧

### ADD

#### 仕様

- LSトップの2つの数値で加算します。
- LSトップの2要素がポップされ、演算結果がプッシュされます。

#### 処理手順

1. LSをポップ ... 2回
2. LSに演算結果をプッシュ ... 1回

#### 使用手順

1. LSに2つの数値をプッシュ
2. ADD命令を実行

### SUB

#### 仕様

- LSトップの2つの数値で減算します。
- LSトップの2要素がポップされ、演算結果がプッシュされます。

#### 処理手順

1. LSをポップ ... 2回
2. LSに演算結果をプッシュ ... 1回

#### 使用手順

1. LSに2つの数値をプッシュ
2. SUB命令を実行

### MUL

#### 仕様

- LSトップの2つの数値で乗算します。
- LSトップの2要素がポップされ、演算結果がプッシュされます。

#### 処理手順

1. LSをポップ ... 2回
2. LSに演算結果をプッシュ ... 1回

#### 使用手順

1. LSに2つの数値をプッシュ
2. MUL命令を実行

### DIV

#### 仕様

- LSトップの2つの数値で除算します。
- LSトップの2要素がポップされ、演算結果がプッシュされます。

#### 処理手順

1. LSをポップ ... 2回
2. LSに演算結果をプッシュ ... 1回

#### 使用手順

1. LSに2つの数値をプッシュ
2. DIV命令を実行

### land

### lor

### CALL

#### 仕様

- LSに設定されたラベルの位置まで移動します。

#### 処理手順

1. LSをポップ ... 1回
1. ラベル位置まで移動
2. LLを新規作成 ... 1コール分
3. LLに引数をプッシュ ... 引数の個数分

#### 使用手順

1. LSにラベル識別子をプッシュ
2. CALL命令を実行

### callmem [LLインデックス] [関数識別子]

### RETURN

#### 仕様

- LSに設定された戻り値を返してラベルから抜け出します。

#### 処理手順

1. LSをポップ ... 1回
2. 

#### 使用手順


### llset [LLインデックス] [値]

ローカルリストに値を設定します。

### lspush [LSインデックス]

ローカルスタックに値をプッシュします。



< スレッドリスト (TL) >

    スレッドリストは各スレッドの情報を保持します。
    スレッド作成ごとにリストに情報が追加されます。
    このリストの要素はGLをもちます。

< グループリスト (GL) >

    グループリストは各グループの情報を保持します。
    関数呼び出しごとにリストに情報が追加されます。
    このリストの要素はLLとLSをもちます。

< ローカルリスト (LL) >

    ローカルリストはローカル変数などのリスト保持に適したデータを保持します。

< ローカルスタック (LS) >

    ローカルスタックは引数や演算結果などのスタック保持に適したデータを保持します。

< 関数呼び出し >

    1.spush命令でスタックに引数をプッシュ
    2.call命令で関数を呼ぶ

    call命令により引数の長さ分だけスタックがポップされます。
    呼び出し先の関数内でreturn命令を出すことで、呼び出し元の関数のスタックに戻り値がプッシュされます。



goto 関数内の番号で？
